#!/usr/bin/env node

'use strict';

var fs = require('fs');

var ethers = require('ethers');
var readlineSync = require('readline-sync');

var Registrar = require('../index');

var getopts = require('ethers-cli/lib/utils').getopts;

var version = require('../package.json').version;

function getPassword(message) {
    if (!message) { message = 'Account Password: '; }
    var password = readlineSync.question(message, {hideEchoBack: true});
    return ethers.utils.toUtf8Bytes(password.normalize('NFKC'));
}

function isValidHashRegistrarName(name) {
    return !!(name.match(/^[a-zA-Z0-9_-]+\.eth$/));
}

function isValidName(name) {
    return !!(name.match(/^[a-zA-Z0-9_.-]+\.eth$/));
}

function showHelp(error) {
    console.log('');
    console.log('Command Line Interface - ethers-ens/' + version);
    console.log('');
    console.log('Usage:');
    console.log('');
    console.log('    ethers-ens init FILENAME');
    console.log('    ethers-ens info FILENAME [--check-password]');
    console.log('');
    console.log('    ethers-ens lookup NAME [ NAME ... ]');
    console.log('    ethers-ens scan-log');
    //console.log('    ethers-ens check-bid SEALED_BID');
    console.log('    ethers-ens watch NAME [ NAME ... ]');
    console.log('    ethers-ens ignore NAME [ NAME ... ]');
    console.log('');
    console.log('    ethers-ens import-bid FILENAME');
    console.log('');
    console.log('    ethers-ens start-auction NAME');
    console.log('    ethers-ens bid NAME AMOUNT [--extra AMOUNT] [--salt SALT | --secret SECRET]');
    console.log('    ethers-ens reveal-bid NAME AMOUNT [--salt SALT | --secret SECRET]');
    console.log('    ethers-ens finalize-auction NAME');
    console.log('');
    console.log('    ethers-ens set-resolver NAME [--resolver ADDRESS]');
    console.log('    ethers-ens set-address NAME ADDRESS');
    console.log('    ethers-ens set-email NAME EMAIL');
    console.log('    ethers-ens set-publickey NAME PUBLICKEY');
    console.log('    ethers-ens set-url NAME URL');
    console.log('    ethers-ens set-text NAME KEY VALUE');
    console.log('');
    console.log('    ethers-ens send ADDRESS AMOUNT'); // @TODO: add --gas-limit
    console.log('');
    console.log('    ethers-ens set-owner NAME ADDRESS');
    console.log('    ethers-ens set-subnode LABEL.NAME [--owner OWNER]');
    console.log('');
    console.log('    ethers-ens register NAME [--extra EXTRA] [--registrar REGISTRAR]');
    console.log('');
    console.log('Options');
    console.log('    --account ACCOUNT  The JSON wallet to use');
    console.log('    --rpc NODE         Use the JSON-RPC node');
    console.log('    --testnet          Use the ropsten test network');
    console.log('    --check-password   Require the password to check JSON wallet');
    console.log('    --extra EXTRA      Send extra ether to mask the bid value');
    console.log('    --salt SALT        The salt to use (otherwise compute; recommended)');
    console.log('    --secret SECRET    Use keccak256(secret) as the salt');
    console.log('    --nonce NONCE      Override the nonce used in transactions');
    console.log('    --gas-price PRICE  Set the gas price (in GWei)');
    console.log('    --cheap            Use low (4.1 GWei) gas price');
    console.log('    --nolog            Do not log activity to ens-log.txt');
    console.log('    --help             Show this help screen');
    console.log('');

    if (error) {
        console.log('Error: ' + error.message);
        console.log('');
        process.exit(1);
    }

    process.exit(0);
}

var command = null;
var registrar = null;

try {
    var opts = getopts({
        account: '',
        extra: '',
        'gas-price': '',
        nonce: '',
        owner: '',
        registrar: '',
        resolver: '',
        rpc: '',
        salt: '',
        secret: ''
    }, {
        'check-password': false,
        'cheap': false,
        'help': false,
        'nolog': false,
        'testnet': false,
    });

    if (opts.flags.help) { showHelp();  }

    if (opts.args.length === 0) {
        throw new Error('no command provided');
    }

    var command = opts.args.shift();

    // Prepare a provider (possibly on testnet)
    if (opts.options.rpc) {
        var provider = new ethers.providers.JsonRpcProvider(opts.options.rpc, opts.flags.testnet);
    } else {
        //var provider = new ethers.providers.EtherscanProvider(opts.flags.testnet);
        //var provider = new ethers.providers.InfuraProvider(opts.flags.testnet);
        var provider = ethers.providers.getDefaultProvider(opts.flags.testnet);
    }
    var providerOrSigner = provider;

    if (opts.options.nonce) {
        if (!opts.options.nonce.match(/^[0-9]+$/)) {
            throw new Error('invalid NONCE');
        }
        opts.options.nonce = parseInt(opts.options.nonce);
    }

    var gasPrice = null;

    if (opts.options['gas-price']) {
        if (opts.flags.cheap) {
            throw new Error('cannot use --gas-price and --cheap together');
        }

        try {
            // We will do some hackery to parse this; the units function will support this soon
            gasPrice = ethers.utils.parseEther(opts.options['gas-price']);

            // Make sure the bottom 9 digits are 0 (Gwei vs ether)
            if (!gasPrice.mod(1000000000).isZero()) {
                throw new Error('too many decimal places');
            }

            // Remove the bottom 9 zeros
            gasPrice = gasPrice.div(1000000000);

        } catch (error) {
            throw new Error('invalid gas PRICE');
        }

    } else if (opts.flags.cheap) {
         // 4.1 GWei
         gasPrice = ethers.utils.bigNumberify("0xf4610900");
    }

    // Read and decrpyt the wallet if an account is required
    function requireAccount() {
        if (!opts.options.account) { throw new Error(command + ' requires an account'); }

        if (gasPrice) {
            console.log('Gas Price: ' + ethers.utils.formatEther(gasPrice.mul(1000000000)) + ' GWei');
        }

        var data = fs.readFileSync(opts.options.account).toString();
        var address = ethers.utils.getAddress(JSON.parse(data).address);

        var accountPromise = null;

        function getAccount() {
            if (accountPromise) { return accountPromise; }

            // Decrypt the account and attach the provider
            accountPromise = new Promise(function(resolve, reject) {
                ethers.Wallet.fromEncryptedWallet(data, getPassword()).then(function(account) {
                    account.provider = provider;
                    resolve(account);
                }, function(error) {
                    reject(error);
                });
            });

            return accountPromise;
        }

        // Custom signer to defer operations until the account is decrypted
        providerOrSigner = {
            getAddress: function() {
                return Promise.resolve(address);
            },
            sendTransaction: function(transaction) {
                return getAccount().then(function(account) {
                    if (address !== account.address) {
                        throw new Error('account mismatch!');
                    }

                    if (gasPrice) {
                        transaction.gasPrice = gasPrice;
                    }

                    if (transaction.nonce == null && opts.options.nonce) {
                        transaction.nonce = opts.options.nonce;
                    }

                    return account.sendTransaction(transaction);
                });
            },
            getSalt: function(tag) {
                return getAccount().then(function(account) {
                    if (address !== account.address) {
                        throw new Error('account mismatch!');
                    }

                    var salt = account.privateKey;
                    salt = ethers.utils.keccak256(salt);
                    salt = ethers.utils.concat([ethers.utils.toUtf8Bytes('salt'), salt]);
                    salt = ethers.utils.keccak256(salt);
                    salt = ethers.utils.concat([ethers.utils.toUtf8Bytes(tag), salt]);
                    return ethers.utils.keccak256(salt);
                });
            },
            provider: providerOrSigner,
        };
    }

    // If a salt is allowed, make sure the salt is a valid 32 byte hexidecimal
    // value or if secret is provided, compute the salt
    function allowSalt() {
        if (opts.options.salt) {
            if (opts.options.secret) {
                throw new Error('may only specify one of --salt or --secret');
            }
            if (!opts.options.salt.match(/^0x[0-9A-Fa-f]{64}$/)) {
                throw new Error('invalid salt');
            }
        } else if (opts.options.secret) {
            opts.options.salt = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(opts.options.secret));
        }
    }

    function ensureArgs(count, message) {
        if (opts.args.length !== count) {
            throw new Error(message);
        }
    }

    function ensureHashRegistrar(name) {
        if (!isValidHashRegistrarName(name)) {
            throw new Error('NAME must be LABEL.eth');
        }
    }

    function parseEther(argument, message) {
        try {
            if (typeof(argument) === 'number') {
                opts.args[argument] = ethers.utils.parseEther(opts.args[argument]);
            } else {
                opts.options[argument] = ethers.utils.parseEther(opts.options[argument]);
            }
        } catch (error) {
            throw new Error(message);
        }
    }

    // Check command line options are valid
    switch (command) {
        case 'init':
            ensureArgs(1, 'must specify a JSON wallet');
            break;

        case 'info':
            ensureArgs(1, 'must specify a JSON wallet');
            if (opts.flags['check-password']) {
                opts.options.account = opts.args[0];
                requireAccount();
            }
            break;

        case 'lookup':
            if (opts.args.length === 0) {
                throw new Error('"lookup" requires NAME [ NAME ... ]');
            }
            break;

        case 'scan-log':
            break;

        case 'watch':
            if (opts.args.length === 0) {
                throw new Error('"watch" requires NAME [ NAME ... ]');
            }
            break;

        case 'ignore':
            if (opts.args.length === 0) {
                throw new Error('"ignore" requires NAME [ NAME ... ]');
            }
            break;

        case 'import-bid':
            ensureArgs(1, '"import-bid" requires FILENAME');
            break;

        case 'start-auction':
            ensureArgs(1, '"start-auction" requires NAME');
            ensureHashRegistrar(opts.args[0]);
            requireAccount();
            break;

        case 'bid':
            ensureArgs(2, '"bid" requires NAME and AMOUNT');
            ensureHashRegistrar(opts.args[0]);
            parseEther(1, 'invalid bid AMOUNT')
            if (opts.options.extra) {
                parseEther('extra', 'invalid extra AMOUNT')
            }
            allowSalt();
            requireAccount();
            break

        case 'reveal-bid':
            ensureArgs(2, '"reveal-bid" requires NAME and AMOUNT');
            ensureHashRegistrar(opts.args[0]);
            parseEther(1, 'invalid bid AMOUNT');
            allowSalt();
            requireAccount();
            break;

        case 'finalize-auction':
            ensureArgs(1, '"finalize-auction" requires NAME');
            ensureHashRegistrar(opts.args[0]);
            requireAccount();
            break;

        case 'send':
            ensureArgs(2, '"send" requires ADDRESS and AMOUNT');
            //checkAddress(0, ...)
            parseEther(1, 'invalid AMOUNT')
            requireAccount();
            break;

        case 'set-resolver':
            ensureArgs(1, '"set-resolver" requires NAME');
            /*
            if (!opts.options.resolver) {
                opts.options.resolver = Registrar.config[provider.testnet ? 'testnet': 'mainnet'].publicResolver;
            }
            */
            requireAccount();
            break;

        case 'set-address':
            ensureArgs(2, '"set-address" requires NAME and ADDRESS');
            requireAccount();
            break;

        case 'set-email':
            ensureArgs(2, '"set-email" requires NAME and EMAIL');
            requireAccount();
            break;

        case 'set-publickey':
            ensureArgs(2, '"set-publickey" requires NAME and PUBLICKEY');
            requireAccount();
            break;

        case 'set-url':
            ensureArgs(2, '"set-url" requires NAME and URL');
            requireAccount();
            break;

        case 'set-text':
            ensureArgs(3, '"set-text" requires NAME, KEY and VALUE');
            requireAccount();
            break;

        case 'set-owner':
            ensureArgs(2, '"set-owner" requires NAME and ADDRESS');
            requireAccount();
            break;

        case 'set-subnode':
            ensureArgs(1, '"set-subnode" requires LABEL.NAME');
            requireAccount();

            // If owner is specified, make sure it is a valid address
            if (opts.options.owner) {
                ethers.utils.getAddress(opts.options.owner);
            }

            break;

        case 'register':
            ensureArgs(1, '"register" requires NAME');
            requireAccount();

            if (opts.options.extra) {
                parseEther('extra', 'invalid EXTRA');
            }

            // Make sure it is a valid name
            try {
                ethers.utils.namehash(opts.args[0]);
            } catch (error) {
                console.log(error);
                throw new Error('invalid name');
            }

            var comps = opts.args[0].split('.');

            // Get the label to register
            opts.args[0] = comps.shift();

            // If no specified registrar, guess (registrar.NAME)
            if (!opts.options.registrar) {
                opts.options.registrar = 'registrar.' + comps.join('.');
            } else if (comps.length < 2) {
                throw new Error('invalid NAME');
            }

            break;

        default:
            throw new Error('unknown command - ' + command);
    }

    // If there was an account required, the providerOrSigner has entangled it in,
    // the above switch/case statement, so we can now bind it to the registrar
    registrar = new Registrar(providerOrSigner);

    // Make sure people know who they are talking to
    console.log('Network: ' + (registrar.provider.testnet ? "testnet": "mainnet"));

} catch (error) {
    showHelp(error);
}

// 20 spaces
var Space = '                    ';
var Space30 = '                              ';
var Space40 = '                                        ';
function addLog(action, info) {
    if (opts.flags.nolog) { return; }

    info.network = (registrar.provider.testnet ? "testnet": "mainnet");

    // Prepare the log (action and date)
    var log = action + ' - ' + getDate(new Date()) + '\n';

    // Add each sorted key
    var keys = Object.keys(info);
    keys.sort();
    keys.forEach(function(key) {
        log += '  ' + key + ':' + Space.substring(key.length) + info[key] + '\n';
    });

    // Append it to the log
    fs.appendFileSync('ens-log.txt', log);
}


function zeroPad(value, length) {
    value = String(value);
    while (value.length < length) { value = '0' + value; }
    return value;
}

// Return YYYY-mm-dd HH:MM:SS
function getDate(date) {
    return (
        date.getFullYear() + '-' +
        zeroPad(date.getMonth() + 1, 2) + '-' +
        zeroPad(date.getDate(), 2) + ' ' +
        zeroPad(date.getHours(), 2) + ':' +
        zeroPad(date.getMinutes(), 2) + ':' +
        zeroPad(date.getSeconds(), 2)
    )
}

// Return the delta time between now and the timestamp
function getTimer(timestamp) {
    var dt = (timestamp.getTime() - (new Date()).getTime()) / 1000;
    var negative = false;
    if (dt < 0) {
        negative = true;
        dt *= -1;
    }

    if (dt === 0) { return '0'; }

    var result = [];
    [60, 60, 24, 365, 1000].forEach(function(chunk) {
        var amount = dt;
        if (amount === 0) { return; }

        var amount = zeroPad(parseInt(amount % chunk), 2);
        dt = parseInt(dt / chunk);
        result.unshift(amount);
    })

    result = result.join(":");

    // Trim leading zeros
    while (result.length > 1 && result.match(/^[0:].+/)) {
        result = result.substring(1);
    }

    if (negative) { result = '-' + result; }

    return result;
}

// Make a readable human date with a timer
function getHumanDate(timestamp) {
    var timer = getTimer(timestamp);
    if (timer.substring(0, 1) === '-') {
        timer = ' (' + timer.substring(1) + ' ago)';
    } else {
        timer = ' (in ' + timer + ')';
    }
    return getDate(timestamp) + timer;
}

// Fetch all info about a name we could care about
function getNameInfo(name, extra) {

    var promises = [
        registrar.getResolver(name),
        registrar.getOwner(name),
        registrar.getAddress(name)
    ];

    if (extra) {
        promises.push(registrar.getPublicKey(name));
        promises.push(registrar.getText(name, 'url'));
        promises.push(registrar.getText(name, 'email'));
    }

    if (isValidHashRegistrarName(name)) {
        promises.push(registrar.getAuction(name));
        promises.push(registrar.getAuctionStartDate(name));
    }

    return Promise.all(promises).then(function(result) {
        var nameInfo = {
            resolver: result[0],
            owner: result[1],
            addr: result[2],
            name: name
        };

        var index = 3;

        if (extra) {
            nameInfo.publicKey = result[index++];
            nameInfo.url = result[index++];
            nameInfo.email = result[index++];
        }

        if (isValidHashRegistrarName(name)) {
            var info = result[index++];
            ['endDate', 'highestBid', 'revealDate', 'state', 'value', 'winningDeed'].forEach(function(key) {
                nameInfo[key] = info[key];
            });
            nameInfo.startDate = result[index++];

            if (nameInfo.winningDeed !== '0x0000000000000000000000000000000000000000') {
                return registrar.getDeedOwner(nameInfo.winningDeed).then(function(owner) {
                    nameInfo.winningBidder = owner;
                    return nameInfo;
                });
            }
        }

        return nameInfo;
    })
}

function dumpNameInfo(result) {
    if (result.state) {
        console.log('  State:                ' + result.state);
        console.log('  Available Start Date: ' + getHumanDate(result.startDate));
    }
    if (result.state == 'auction' || result.state == 'reveal' || result.state == '') {
        console.log('  Auction Reveal Date:  ' + getHumanDate(result.revealDate));
        console.log('  Auction End Date:     ' + getHumanDate(result.endDate));
    }
    if (result.state == 'reveal' || result.state == 'owned') {
        console.log('  Winning Deed:         ' + result.winningDeed);
        console.log('  Winning Bidder:       ' + result.winningBidder);
        console.log('  Value:                ' + ethers.utils.formatEther(result.value));
        console.log('  Highest Bid:          ' + ethers.utils.formatEther(result.highestBid));
    }
    if (result.state == 'owned' || !result.state) {
        console.log('  Owner:                ' + result.owner);
        console.log('  Resolver:             ' + result.resolver);
        console.log('  Address:              ' + result.addr);
        if (result.publicKey) {
            console.log('  Public Key:           ' + result.publicKey);
        }
        if (result.email) {
            console.log('  Email:                ' + result.email);
        }
        if (result.url) {
            console.log('  URL:                  ' + result.url);
        }
    }
}

function loadLog() {
    var network = provider.testnet ? 'testnet': 'mainnet';

    var data = '';
    try {
        data = fs.readFileSync('ens-log.txt').toString();
    } catch (error) {
        // File doesn't exist, so no log to load
        if (error.code !== 'ENOENT') { throw error; }
    }

    var entries = [], entry = {};
    data.split('\n').forEach(function(line) {
        if (line.substring(0, 1) === '#') { return; }
        if (line.substring(0, 2) === '  ') {
            var comps = line.split(/:/);
            entry[comps[0].trim()] = comps[1].trim();
        } else if (line.indexOf(' - ') >= 0) {
            entry = {};
            var comps = line.split(' - ');
            entry.command = comps[0];
            entry.date = comps[1];
            entries.push(entry);
        }
    });

    // Check chonologically for ignore/watch commands for the most recent stste
    var ignore = {};
    entries.forEach(function(entry) {
        if (entry.command === 'ignore') {
            ignore[entry.name] = true;
        } else if (entry.command === 'watch') {
            ignore[entry.name] = false;
        }
    });

    // Filter out entries we don't care about
    var filtered = [];
    entries.forEach(function(entry) {
        if (entry.network !== network) { return; }
        if (entry.command === 'ignore') { return; }
        if (ignore[entry.name]) { return; }
        filtered.push(entry);
    });

    return filtered;
}

function getMaxBid(auction) {
    var maxBidAmount = ethers.utils.bigNumberify(0);
    auction.operations.forEach(function(operation) {
        if (operation.command !== 'placeBid') { return; }
        var bidAmount = ethers.utils.parseEther(operation.bidAmount);
        if (bidAmount.gte(maxBidAmount)) {
            maxBidAmount = bidAmount;
        }
    });
    return ethers.utils.formatEther(maxBidAmount);
}
var ZeroAddress = '0x0000000000000000000000000000000000000000';

switch (command) {
    case 'init':
        (function() {
            var filename = opts.args.shift();
            if (fs.existsSync(filename)) {
                console.log('Filename already exists; cannot overwrite');
                process.exit(1);
            }
            console.log('Initializing a new JSON wallet - ' + filename);
            console.log('Keep this password and file SAFE!! If lost or forgotten');
            console.log('it CANNOT be recovered, by ANYone, EVER.');

            var password = getPassword();
            var confirmPassword = getPassword('Confirm Password: ')
            if (ethers.utils.hexlify(password) != ethers.utils.hexlify(confirmPassword)) {
                console.log('Passwords did not match.');
                process.exit(1);
            }

            var wallet = ethers.Wallet.createRandom();
            wallet.encrypt(password).then(function(json) {

                // Add nice spacing to the JSON
                json = JSON.stringify(JSON.parse(json), undefined, 4);

                try {
                    fs.writeFileSync(filename, json, { flag: 'wx' });
                    console.log('New account address: ' + wallet.address);
                } catch (error) {
                    if (error.code === 'EEXIST') {
                        console.log('Filename already exists; cannot overwrite');
                    } else {
                        console.log('Unknown Error: ' + error.message);
                    }
                }
            });
        })();
        break;

    case 'info':
        (function() {
            var filename = opts.args.shift();
            if (!fs.existsSync(filename)) {
                console.log('Filename not found.');
                process.exit(1);
            }

            function showInfo(address) {
                console.log('Address: ' + address);
                Promise.all([
                    registrar.provider.getBalance(address),
                    registrar.provider.getTransactionCount(address, 'latest'),
                    registrar.provider.getTransactionCount(address, 'pending'),
                ]).then(function(result) {
                    console.log('Balance:                     ' + ethers.utils.formatEther(result[0]));
                    console.log('Transaction Count (latest):  ' + result[1]);
                    console.log('Transaction Count (pending): ' + result[2]);
                });
            }

            var json = fs.readFileSync(filename);
            if (opts.flags['check-password']) {
                providerOrSigner.getAddress().then(function(address) {
                    console.log('Password OK!');
                    showInfo(address);
                });
            } else {
                showInfo(ethers.utils.getAddress(JSON.parse(json).address));
            }
        })();
        break;

    // Lookup one of more domains
    case 'lookup':
        (function() {
            var namePromises = [];
            opts.args.forEach(function(name) {
                if (!isValidName(name)) {
                    console.log('Invalid ENS Name: ' + name);
                    return;
                }
                namePromises.push(getNameInfo(name, true));
            });

            Promise.all(namePromises).then(function(results) {
                results.forEach(function(result) {
                    console.log(result.name);
                    dumpNameInfo(result);
                });
            });
        })();
        break;

    // Coming Soon!
    // Scan the log and report any warnings
    //   - startAuction, but no bids
    //   - placeBid, but no revealBid
    //   - placeBid and won, but no finalizeAuction
    case 'scan-log':
        (function() {

            var entries = loadLog();
            var names = {};
            entries.forEach(function(entry) {
                if (entry.name) {
                    if (!names[entry.name]) {
                        names[entry.name] = { operations: [], name: entry.name};
                    }
                    names[entry.name].operations.push(entry);
                 }
            });

            function getDeeds(auction) {
                var promises = [];
                auction.operations.forEach(function(operation) {
                    if (operation.command !== 'placeBid') { return; }

                    var promise = null;

                    // Get the sealed bid (or look if up if necessary)
                    if (operation.sealedBid) {
                        promise = Promise.resolve(operation.sealedBid);
                    } else {
                        promise = registrar.getBidHash(
                            operation.name,
                            operation.address,
                            ethers.utils.parseEther(operation.bidAmount),
                            operation.salt
                       );
                    }

                    // Get the deed address
                    promise = promise.then(function(sealedBid) {
                        return registrar.getDeedAddress(operation.address, sealedBid);
                    });

                    // Add extra details
                    promise = promise.then(function(deed) {
                        return {
                            address: deed,
                            bidAmount: operation.bidAmount,
                            sealedBid: operation.sealedBid
                        }
                    });

                    promises.push(promise);
                });

                return Promise.all(promises);
            }

            var auctionPromises = [];

            Object.keys(names).forEach(function(name) {
                var auction = names[name];

                // Non-auction name
                if (!isValidHashRegistrarName(name)) { return; }

                var auctionPromise = registrar.getAuction(auction.name).then(function(result) {

                    var ret = Promise.resolve({
                        date: result.endDate,
                        endDate: result.endDate,
                        name: auction.name,
                        state: result.state,
                        value: ethers.utils.formatEther(result.value),
                        winningBidAmount: ethers.utils.formatEther(result.highestBid),
                    });

                    if (result.state === 'open' || result.state === 'not-yet-available') {
                        // The interesting date is the auction start date; look it up
                        ret = ret.then(function(ret) {
                            return registrar.getAuctionStartDate(auction.name).then(function(startDate) {
                                ret.date = startDate;
                                return ret;
                            });
                        });
                    }

                    if (result.state === 'owned') {
                        ret = ret.then(function(ret) {
                            return Promise.all([
                                registrar.getOwner(auction.name),
                                registrar.getDeedOwner(result.winningDeed)
                            ]).then(function(result) {
                                ret.winning = false;
                                auction.operations.forEach(function(operation) {
                                    ret.owner = result[0];
                                    if (operation.address === result[0] || operation.address === result[1]) {
                                        ret.winning = true;
                                        ret.bidAmount = ret.winningBidAmount;
                                    }
                                });
                                if (!ret.winning) {
                                    ret.bidAmount = getMaxBid(auction);
                                }
                                return ret;
                            });
                        });
                    }

                    // Make sure our placeBids have deeds
                    if (result.state === 'auction') {
                        // The interesting date is when the bidding end date
                        ret = ret.then(function(ret) {
                            ret.date = result.revealDate;
                            ret.bidAmount = getMaxBid(auction);
                            return getDeeds(auction).then(function(deeds) {
                                ret.deedAddresses = [];
                                deeds.forEach(function(deed) {
                                    ret.deedAddresses.push(deed.address);
                                });
                                return ret;
                            })
                        });
                    }

                    if (result.state === 'reveal') {

                        // Let's find out if we're winning
                        if (result.winningDeed != ZeroAddress) {
                            ret = Promise.resolve(ret).then(function(ret) {
                                return registrar.getDeedOwner(result.winningDeed).then(function(deed) {
                                    ret.winning = false;
                                    auction.operations.forEach(function(operation) {
                                        if (operation.address === deed) {
                                            ret.winning = true;
                                            ret.bidAmount = operation.bidAmount;
                                        }
                                    });
                                    if (!ret.winning) {
                                        ret.bidAmount = getMaxBid(auction);
                                    }
                                    return ret;
                                });
                            });
                        } else {
                            ret = ret.then(function(ret) {
                                ret.bidAmount = getMaxBid(auction);
                                return ret;
                            });
                        }

                        ret = ret.then(function(ret) {
                            return getDeeds(auction).then(function(deeds) {
                                ret.deedAddresses = [];
                                deeds.forEach(function(deed) {
                                    ret.deedAddresses.push(deed.address);
                                });
                                return ret;
                            })
                        });
                    }

                    return ret;
                });
                auctionPromises.push(auctionPromise);
            });

            Promise.all(auctionPromises).then(function(result) {

                function compareString(a, b) {
                    if (a < b) { return -1; }
                    if (a > b) { return 1; }
                    return 0;
                }
                result.sort(function(a, b) {
                    if (a.state === 'not-yet-available') {
                        if (b.state === 'open') { return -1; }
                        if (a.state === b.state) { return (a.date.getTime() - b.date.getTime()); }
                    } else if (a.state === 'open') {
                        if (b.state === 'not-yet-available') { return 1; }
                        if (a.state === b.state) { return (a.date.getTime() - b.date.getTime()); }
                    }
                    return a.endDate.getTime() - b.endDate.getTime();
                });

                var warnings = [];

                var lastState = null;
                result.forEach(function(result) {
                    if (result.state !== lastState) {
                        console.log(result.state);
                        lastState = result.state;
                    }
                    var dateInfo = getHumanDate(result.date);

                    var warn = false;
                    if (result.state === 'auction' && result.deedAddresses) {
                        result.deedAddresses.forEach(function(address) {
                            if (address !== ZeroAddress) { return; }
                            warnings.push('placeBid(' + result.name + ', ' + result.bidAmount + ') is missing on the blockchain');
                            warn = true;
                        });
                    }

                    if (result.state === 'reveal' && result.deedAddresses) {
                        result.deedAddresses.forEach(function(address) {
                            if (address === ZeroAddress) { return; }
                            warnings.push('revealBid(' + result.name + ', ' + result.bidAmount + ') has not been called');
                            warn = true;
                        });
                    }

                    if (result.state === 'owned' && result.owner === ZeroAddress && result.winning) {
                        warnings.push('finalizeAuction(' + result.name + ') has not been called');
                        warn = true;
                    }

                    var bidInfo = ' ';
                    bidInfo += (warn ? '!! ': '   ');
                    bidInfo += (result.winning ? '* ': '  ');

                    if (result.state === 'auction' && result.bidAmount !== '0.0') {
                        bidInfo += result.bidAmount;
                    } else if (result.state === 'reveal' || result.state === 'owned') {
                        if (result.bidAmount === '0.0') {
                            bidInfo += result.winningBidAmount;
                            bidInfo += '/';
                            bidInfo += result.value;
                        } else {
                            if (!result.winning) {
                                bidInfo += result.bidAmount;
                                bidInfo += '/';
                            }
                            bidInfo += result.winningBidAmount;
                            bidInfo += '/';
                            bidInfo += result.value;
                        }
                    }

                    console.log('  ' +
                                result.name +
                                Space.substring(result.name.length) +
                                dateInfo +
                                Space40.substring(dateInfo.length) +
                                bidInfo);
                });

                if (warnings.length) {
                    warnings.forEach(function(warning) {
                        console.log('Warning: ' + warning);
                    });
                }
            });

        })();
        break;

    case 'watch':
        (function() {
            var getInfoPromises = [];

            opts.args.forEach(function(name) {
                if (!isValidHashRegistrarName(name)) {
                    console.log('Invalid ENS Name: ' + name);
                    return;
                }
                getInfoPromises.push(getNameInfo(name));
            });

            Promise.all(getInfoPromises).then(function(result) {
                result.forEach(function(result) {
                    console.log(result.name);

                    dumpNameInfo(result);

                    var watching = false;
                    loadLog().forEach(function(log) {
                        if (log.command === 'watch' && log.name === result.name) {
                            watching = true;
                        }
                    });

                    if (!watching) {
                        addLog('watch', {
                            name: result.name,
                            startDate: result.startDate.getTime()
                        });
                    }
                });
            });
        })();
        break;

    case 'ignore':
        (function() {
            var getInfoPromises = [];

            opts.args.forEach(function(name) {
                if (!isValidHashRegistrarName(name)) {
                    console.log('Invalid ENS Name: ' + name);
                    return;
                }
                getInfoPromises.push(getNameInfo(name));
            });

            Promise.all(getInfoPromises).then(function(result) {
                result.forEach(function(result) {
                    console.log(result.name);

                    dumpNameInfo(result);

                    addLog('ignore', {
                        name: result.name
                    });
                });
            });
        })();
        break;

    case 'import-bid':
        (function() {
            var filename = opts.args.shift();
            if (!fs.existsSync(filename)) {
                console.log('Filename not found.');
                process.exit(1);
            }
            try {
                var data = JSON.parse(fs.readFileSync(filename));

                var salt = ethers.utils.hexlify(data.secretSHA3);
                if (salt.length !== 66) { throw new Error('invalid salt'); }

                addLog('placeBid', {
                    import: filename,
                    address: ethers.utils.getAddress(data.owner),
                    bidAmount: ethers.utils.formatEther(data.value),
                    labelHash: data.nameSHA3,
                    name: data.name + '.eth',
                    salt: salt,
                });
                console.log('  Import:               ' + filename);
                console.log('  Name:                 ' + data.name + '.eth');
                console.log('  Bid Amount:           ' + ethers.utils.formatEther(data.value));
                console.log('  Address:              ' + ethers.utils.getAddress(data.owner));
                console.log('  Label Hash:           ' + data.nameSHA3);
                console.log('  Salt:                 ' + salt);
            } catch (error) {
                console.log(error);
            }
        })();
        break;

    case 'start-auction':
        (function() {
            var name = opts.args.shift();
            getNameInfo(name).then(function(result) {
                var errors = {
                    'auction': 'name already up for auction; please "bid" before ' + getHumanDate(result.revealDate),
                    'owned': 'name already owned',
                    'forbidden': 'name forbidden',
                    'reveal': 'bidding closed; please "reveal" your bid before ' + getHumanDate(result.endDate),
                    'not-yet-available': ('name not available until ' + getHumanDate(result.startDate))
                };
                if (errors[result.state]) {
                    console.log('  Error: ' + errors[result.state]);
                } else {
                    registrar.startAuction(name).then(function(result) {
                        addLog('startAuction', {
                            address: result.from,
                            name: name,
                            labelHash: result.labelHash,
                            transactionHash: result.hash
                        });
                        console.log('  Label Hash:           ' + result.labelHash);
                        console.log('  Transaction Hash:     ' + result.hash);
                    });
                }
            });
        })();
        break;

    case 'bid':
        (function() {
            var name = opts.args.shift();
            var bidAmount = opts.args.shift();
            var salt = opts.options.salt;
            var extraAmount = (opts.options.extra || ethers.utils.bigNumberify(0));
            getNameInfo(name).then(function(result) {
                var errors = {
                    'open': 'name not up for auction yet; please "start" first',
                    'owned': 'name already owned',
                    'forbidden': 'name forbidden',
                    'reveal': 'bidding closed; please "reveal" your bid before ' + getHumanDate(result.endDate),
                    'not-yet-available': ('name not available until ' + getHumanDate(result.startDate))
                };

                if (errors[result.state]) {
                    console.log('  Error: ' + errors[result.state]);
                } else {
                    registrar.placeBid(name, bidAmount, salt, extraAmount).then(function(result) {
                        addLog('placeBid', {
                            address: result.from,
                            bidAmount: ethers.utils.formatEther(bidAmount),
                            extraAmount: ethers.utils.formatEther(extraAmount),
                            name: name,
                            labelHash: result.labelHash,
                            salt: result.salt,
                            sealedBid: result.sealedBid,
                            transactionHash: result.hash
                        });
                        console.log('  Label Hash            ' + result.labelHash);
                        console.log('  Salt:                 ' + result.salt);
                        console.log('  Sealed Bid:           ' + result.sealedBid);
                        console.log('  Transaction Hash:     ' + result.hash);
                    });
                }
            });
        })();
        break;

    case 'reveal-bid':
        (function() {
            var name = opts.args.shift();
            var bidAmount = opts.args.shift();
            var salt = opts.options.salt;
            getNameInfo(name).then(function(result) {
                var errors = {
                    'auction': ('name still up for auction; wait until ' + getHumanDate(result.revealDate)),
                    'open': 'name not up for auction yet; please "start" first',
                    'forbidden': 'name forbidden',
                    'not-yet-available': ('name not available until ' + getHumanDate(result.startDate))
                };

                if (errors[result.state]) {
                    console.log('  Error: ' + errors[result.state]);
                } else {
                    // No salt, check for a salt for this bid in the log
                    if (!salt) {

                        // Get all matching salts
                        var salts = {};
                        loadLog().forEach(function(operation) {
                            if (operation.command !== 'placeBid') { return; }
                            if (!bidAmount.eq(ethers.utils.parseEther(operation.bidAmount))) { return; }
                            if (operation.name != name) { return; }
                            salts[operation.salt] = true;
                        });

                        // If there is more than one matching salt, very bad things happend:
                        //   - Maybe they imported multiple bids with different salts
                        //   - Forced a salt with this tool multiple times
                        salts = Object.keys(salts);
                        if (salts.length > 1) {
                            console.log('ERROR: Multiple salts found for bid! Reveal each MANUALLY with --salt.');
                            salts.forEach(function(salt) {
                                console.log('  ' + salt);
                            });
                            process.exit(1);
                        }

                        // One salt, use it
                        if (salts.length === 1) { salt = salts[0]; }
                    }

                    registrar.revealBid(name, bidAmount, salt).then(function(result) {
                        addLog('revealBid', {
                            address: result.from,
                            bidAmount: ethers.utils.formatEther(bidAmount),
                            labelHash: result.labelHash,
                            name: name,
                            salt: result.salt,
                            sealedBid: result.sealedBid,
                            transactionHash: result.hash
                        });

                        console.log('  Label Hash            ' + result.labelHash);
                        console.log('  Salt:                 ' + result.salt);
                        console.log('  Sealed Bid:           ' + result.sealedBid);
                        console.log('  Transaction Hash:     ' + result.hash);
                    });
                }
            });
        })();
        break;

    case 'finalize-auction':
        (function() {
            var name = opts.args.shift();
            getNameInfo(name).then(function(result) {
                var errors = {
                    'auction': ('name still up for auction; wait until ' + getHumanDate(result.revealDate)),
                    'open': 'name not up for auction yet; please "start" first',
                    'forbidden': 'name forbidden',
                    'reveal': 'auction closed; please "reveal" your bid before ' + getHumanDate(result.endDate),
                    'not-yet-available': ('name not available until ' + getHumanDate(result.startDate))
                };

                if (errors[result.state]) {
                    console.log('  Error: ' + errors[result.state]);
//                } else if (result.state === 'owned' && result.owner != '0x0000000000000000000000000000000000000000') {
//                    console.log('  Error: auction has already been finalized');
                } else {
                    registrar.finalizeAuction(name).then(function(result) {
                        addLog('finalizeAuction', {
                            address: result.from,
                            name: name,
                            labelHash: result.labelHash,
                            transactionHash: result.hash
                        });
                        console.log('  Label Hash:           ' + result.labelHash);
                        console.log('  Transaction Hash:     ' + result.hash);
                    });
                }
            });
        })();
        break;

    case 'send':
        (function() {
            var address = opts.args.shift();
            var amount = opts.args.shift();
            providerOrSigner.sendTransaction({
                to: address,
                gasLimit: 21000,
                value: amount
            }).then(function(result) {
                console.log('  Transaction Hash:     ' + result.hash);
            });
        })();
        break;
    
    case 'set-resolver':
        (function() {
            var name = opts.args.shift();
            var resolverPromise = null;
            if (opts.options.resolver) {
                resolverPromise = Promise.resolve(opts.options.resolver)
            } else {
                resolverPromise = provider.resolveName('resolver.eth');
            }
            Promise.all([
                getNameInfo(name),
                registrar.signer.getAddress(),
                resolverPromise
            ]).then(function(result) {
                if (result[0].owner !== result[1]) {
                    console.log('  Error: account does not own name');
                } else {
                    var resolver = result[2];
                    registrar.setResolver(name, resolver).then(function(result) {
                        addLog('setResolver', {
                            address: result.from,
                            name: name,
                            nodeHash: result.nodeHash,
                            resolver: resolver,
                            transactionHash: result.hash
                        });
                        console.log('  Node Hash:            ' + result.nodeHash);
                        console.log('  Transaction Hash:     ' + result.hash);
                    });
                }
            });
        })();
        break;

    case 'set-address':
        (function() {
            var name = opts.args.shift();
            var address = opts.args.shift();
            registrar.setAddress(name, address).then(function(result) {
                addLog('setAddress', {
                    address: result.from,
                    addr: result.addr,
                    name: name,
                    nodeHash: result.nodeHash,
                    resolver: result.resolver,
                    transactionHash: result.hash,
                });
                console.log('  Node Hash:            ' + result.nodeHash);
                console.log('  Transaction Hash:     ' + result.hash);
            });
        })();
        break;

    case 'set-publickey':
        (function() {
            var name = opts.args.shift();
            var publickey = opts.args.shift();
            registrar.setPublicKey(name, publickey).then(function(result) {
                addLog('setPublicKey', {
                    address: result.from,
                    publicKey: result.publicKey,
                    name: name,
                    nodeHash: result.nodeHash,
                    transactionHash: result.hash,
                });
                console.log('  Node Hash:            ' + result.nodeHash);
                console.log('  Transaction Hash:     ' + result.hash);
            });
        })();
        break;

    case 'set-email':
    case 'set-url':
    case 'set-text':
        (function() {
            var name = opts.args.shift();

            var textKey = '';
            var textValue = '';

            if (command === 'set-email') {
                textKey = 'email';
                textValue = opts.args.shift();
            } else if (command === 'set-url') {
                textKey = 'url';
                textValue = opts.args.shift();
            } else if (command === 'set-text') {
                textKey = opts.args.shift();
                textValue = opts.args.shift();
            } else {
                throw new Error('Do not enter');
            }

            registrar.setText(name, textKey, textValue).then(function(result) {
                addLog('setText', {
                    address: result.from,
                    key: textKey,
                    text: textValue,
                    name: name,
                    nodeHash: result.nodeHash,
                    transactionHash: result.hash,
                });
                console.log('  Node Hash:            ' + result.nodeHash);
                console.log('  Transaction Hash:     ' + result.hash);
            });
        })();
        break;

    case 'set-owner':
        (function() {
            var name = opts.args.shift();
            var address = opts.args.shift();
            console.log('owner', name, address);
            registrar.setOwner(name, address).then(function(result) {
                addLog('setOwner', {
                    address: result.from,
                    name: name,
                    newOwner: address,
                    nodeHash: result.nodeHash,
                    transactionHash: result.hash,
                });
                console.log('  Node Hash:            ' + result.nodeHash);
                console.log('  Transaction Hash:     ' + result.hash);
            });
        })();
        break;

    case 'set-subnode':
        (function() {
            var name = opts.args.shift();
            var owner = opts.options.owner;

            var match = name.match(/^([^.]+)\.(.+)$/);
            var label = match[1];
            var parentName = match[2];

            // Use the owner, or lookup the owner of the parentName
            if (owner) {
                owner = Promise.resolve(owner);
            } else {
                owner = registrar.getOwner(parentName);
            }

            owner.then(function(owner) {
                registrar.setSubnodeOwner(parentName, label, owner).then(function(result) {
                    addLog('setSubnode', {
                        address: result.from,
                        label: result.label,
                        labelHash: result.labelHash,
                        name: name,
                        owner: owner,
                        parentName: result.parentName,
                        nodeHash: result.nodeHash,
                        transactionHash: result.hash,
                    });
                    console.log('  Node Hash:            ' + result.nodeHash);
                    console.log('  Transaction Hash:     ' + result.hash);
                });
            });
        })();
        break;

    case 'register':
        (function() {
            var label = opts.args.shift();
            var extra = opts.options.extra || 0;
            registrar.getSimpleRegistrar(opts.options.registrar).then(function(simpleRegistrar) {
                if (!simpleRegistrar) {
                    console.log('  Error: ' + opts.options.registrar + ' is not a simple registrar');
                } else {
                    simpleRegistrar.getFee().then(function(fee) {
                        var value = fee.add(extra);

                        console.log('Registrar: ' + opts.options.registrar);
                        console.log('Fee:       ' + ethers.utils.formatEther(fee));
                        if (!fee.eq(value)) {
                            console.log('Total:     ' + ethers.utils.formatEther(value));
                        }
                        simpleRegistrar.register(label, value).then(function(result) {
                            addLog('register', {
                                address: result.from,
                                label: result.label,
                                registrar: opts.options.registrar,
                                transactionHash: result.hash,
                            });
                            console.log('  Transaction Hash:     ' + result.hash);
                        });
                    });
                }
            });
        })();
        break;
}
