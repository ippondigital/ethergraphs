contract AliasRegistry {

    struct Claim {
        address owner;
        uint64 claimDate;
    }

    struct Alias {
        address owner;
        string link;
        uint64 expiry;
        uint128[] keywords;
    }
    
    struct Keyword {
        uint64 nextKeywordId;
        uint64 expiry;
    }

    struct Policy {
    }
    
    Policy _policy;
    Policy _pendingPolicy;

    mapping (bytes32 => Claim) _claims;
    mapping (bytes32 => Alias) _aliases;
    mapping (string => Keyword) _keywordHeads;

    function preregister(bytes32 blindedClaim) {
        Claim claim = _claims[blindedClaim];
        if (claim.owner != address(0)) { throw; }

        claim.owner = msg.sender;
        claim.claimDate = now;
    }
    
    function register(string aliasName) payable {
        Alias alias = _aliases[aliasName];
        if (alias.owner == address(0)) {
            alias.owner = msg.sender;
        } else if (alias.owner != msg.sender) {
            throw;
        }

        alias.expiry = ...
    }

    function update(bytes32 aliasHash, string link) {
        Alias alias = _aliases[aliasHash];
        if (alias.owner != msg.sender) { throw; }

        alias.link = link;
    }

    function lookup(bytes32 aliasHash) constant returns (string link, uint64 expiry, uin128[] keywordIds) {
    }   
    
    function addKeyword(bytes32 aliasHash, string keyword) {
        Alias alias = _aliases[aliasHash];
        if (alias.owner != msg.sender) { throw; }

        uint64 keywordId = _nextKeywordId++;

        alias.keywords.push(keywordId);

        Keyword keyword = _keywords[keywordId];
        keyword.expiry = ...

        keyword.
    }

    function pruneKeyword(bytes32 aliasHash, uint uint64 keywordId) {
    }

    function search(string keyword, uint64 startKeywordId) constant returns (string[]) {
    }
}
